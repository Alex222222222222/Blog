import AsyncLock from "async-lock";
import crypto from "crypto";
import fs from "fs";
import path from "path";
const wildcard = require("wildcard");

const IGNORE_LIST = getIgnoreList();

export const CACHE_DIR: string = ".build_cache";

/// the cache key generated by go through all the posts
const ALL_CACHE_KEY: string = getDirCacheKey("./") || "";

// create the cache directory if it doesn't exist
if (!fs.existsSync(CACHE_DIR)) {
  fs.mkdirSync(CACHE_DIR);
}

/**
 * Get the hash key for a given string
 *
 * @param str string
 *   The string to get the hash key for
 * @returns string
 *   The hash key
 */
export function getHashKey(str: string): string {
  return crypto
    .createHash("sha256")
    .update(ALL_CACHE_KEY)
    .update(str)
    .digest("hex");
}

/**
 * Put a value in the cache for a given key to dir
 *
 * @param storeDir string
 *   The dir to the cache file
 * @param key string
 *   The key to store the value under
 * @param value string
 *   The value to store in the cache
 */
export function putCache(storeDir: string, key: string, value: string): void {
  const cacheDir = path.join(CACHE_DIR, storeDir);
  fs.mkdirSync(cacheDir, { recursive: true });
  fs.writeFileSync(path.join(cacheDir, key), value);
}

/**
 * Read the value in the cache for a given key with path,
 * return undefined if there is no such cache exists.
 *
 * @param storeDir string
 *   The dir to the cache file
 * @param key string
 *   The key to store the value under
 * @returns string | undefined
 *   The value in the cache
 *   or undefined if there is no such cache exists
 */
export function readCache(storeDir: string, key: string): string | undefined {
  const cacheDir = path.join(CACHE_DIR, storeDir);
  fs.mkdirSync(cacheDir, { recursive: true });
  const cachePath = path.join(cacheDir, key);
  if (fs.existsSync(cachePath)) {
    return fs.readFileSync(cachePath, "utf8");
  }
  return undefined;
}

/**
 * Get the cache key for a given directory
 */
function getDirCacheKey(dir: string): string | undefined {
  if (!fs.existsSync(dir) || checkInIgnoreList(dir, IGNORE_LIST)) {
    return undefined;
  }

  // read the dir posts recursively
  const files = fs.readdirSync(dir, { withFileTypes: true });

  let hash = crypto.createHash("sha256");
  for (const file of files) {
    if (checkInIgnoreList(file.name, IGNORE_LIST)) {
      continue;
    }
    if (file.isFile()) {
      hash.update(fs.readFileSync(path.join(dir, file.name), "utf8"));
    } else if (file.isDirectory()) {
      const subDirHash = getDirCacheKey(path.join(dir, file.name));
      if (subDirHash) {
        hash.update(subDirHash);
      }
    }
  }

  return hash.digest("hex");
}

/**
 * Check if the file is in the ignore list, support wildcard
 *
 * @param file
 *   The directory to check
 * @param ignoreList
 *   The ignore list
 * @returns
 *   True if the file is in the ignore list
 */
function checkInIgnoreList(file: string, ignoreList: string[]): boolean {
  for (const ignore of ignoreList) {
    if (wildcard(ignore, file)) {
      return true;
    }
  }
  return false;
}

/**
 * Get the content of .gitignore file return list of ignore
 */
function getIgnoreList(): string[] {
  const ignorePath = path.join(process.cwd(), ".gitignore");
  if (!fs.existsSync(ignorePath)) {
    return [];
  }

  const list = fs
    .readFileSync(ignorePath, "utf8")
    .split("\n")
    .filter((line) => line.trim().length > 0);

  list.push(".git", ".gitignore", ".build_cache", "node_modules");

  return list;
}
